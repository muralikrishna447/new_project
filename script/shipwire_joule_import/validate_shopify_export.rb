require 'csv'
require 'optparse'
require 'shopify_api'
require 'pry'

#
# Validates a Shopify CSV export generated by the 'export_shopify_orders' script.
# The script will validate orders according to issues that are known to cause
# import failures in Shipwire. It will also apply tags to the order indicating
# what needs to be fixed using the Shopify API.
#
# The output of this script is a filtered list of CSV input rows that are deemed
# to be valid.
#
# Options:
#   --key: Your Shopify API key
#   --password: Your Shopify API key password
#   --store: The name of the Shopify store ('delve' for prod, or 'chefsteps-staging')
#   --file: The input CSV file generated by the 'export_shopify_orders' script.
#

# Options parsing
options = {}
option_parser = OptionParser.new do |option|
  option.on('-k', '--key API_KEY', 'Shopify API key') do |api_key|
    options[:api_key] = api_key
  end

  option.on('-p', '--password PASSWORD', 'Shopify password') do |password|
    options[:password] = password
  end

  option.on('-s', '--store STORE', 'Shopify store name') do |store|
    options[:store] = store
  end

  option.on('-f', '--file FILE', 'CSV export file of Shopify orders') do |file|
    options[:file] = file
  end
end

option_parser.parse!
raise '--key is required' unless options[:api_key]
raise '--password is required' unless options[:password]
raise '--store is required' unless options[:store]
raise '--file is required' unless options[:file]

# Configure shopify client
ShopifyAPI::Base.site = "https://#{options[:api_key]}:#{options[:password]}@#{options[:store]}.myshopify.com/admin"

def apply_tags(order_id, tags)
  order = ShopifyAPI::Order.find(order_id)
  raise "Order with id #{order_id} not found" unless order

  order_tags = order.tags.split(',')
  order_tags.each(&:strip!)
  # Only add validation tags that are not already on the order
  tags_to_apply = tags.select { |tag| !order_tags.include?(tag) }
  unless tags_to_apply.empty?
    tags_to_apply.each { |tag| order_tags << tag }
    order.tags = order_tags.join(',')
    STDERR.puts "Adding tags to order with id #{order_id}: #{tags_to_apply.inspect}"
    #order.save
  end
end

filtered_order_rows = []
valid_order_count = 0
invalid_order_count = 0
CSV.foreach(options[:file], headers: true) do |input_row|
  order_errors = []
  order_validation_tags = []

  shipping_address_1 = input_row['shipping_address_1']
  # Some orders have no shipping address
  if shipping_address_1.nil? || shipping_address_1.empty?
    order_errors << 'No shipping address 1 line'
    order_validation_tags << 'validation-shipping-address-1-missing'
  end
  # Shipwire limits address lines to 50 chars
  if shipping_address_1 && shipping_address_1.length > 50
    order_errors << "Shipping address 1 line is too long: #{shipping_address_1}"
    order_validation_tags << 'validation-shipping-address-1-too-long'
  end

  # Shipwire limits address lines to 50 chars
  shipping_address_2 = input_row['shipping_address_2']
  if shipping_address_2 && shipping_address_2.length > 50
    order_errors << "Shipping address 2 line is too long: #{shipping_address_2}"
    order_validation_tags << 'validation-shipping-address-2-too-long'
  end

  if order_validation_tags.empty?
    filtered_order_rows << input_row
    valid_order_count += 1
  else
    STDERR.puts "Filtering order with id #{input_row['id']} with validation errors: #{order_validation_tags}"
    order_validation_tags << 'validation-error'
    apply_tags(input_row['id'], order_validation_tags)
    invalid_order_count += 1
  end
end
STDERR.puts "Found #{valid_order_count} valid orders and filtered #{invalid_order_count} invalid orders"

output_str = CSV.generate(force_quotes: true) do |output_rows|
  output_rows << [
    'id',
    'name',
    'processed_at',
    'shipping_name',
    'shipping_address_1',
    'shipping_address_2',
    'shipping_city',
    'shipping_province',
    'shipping_zip',
    'shipping_country',
    'email',
    'shipping_phone',
    'sku',
    'quantity'
  ]
  filtered_order_rows.each { |row| output_rows << row }
end
puts output_str
